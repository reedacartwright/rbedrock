% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/blocks.R
\name{SubchunkBlocks}
\alias{SubchunkBlocks}
\alias{get_subchunk_blocks_data}
\alias{get_subchunk_blocks_value}
\alias{put_subchunk_blocks_data}
\alias{put_subchunk_blocks_value}
\alias{read_subchunk_blocks_value}
\alias{write_subchunk_blocks_value}
\alias{subchunk_origins}
\alias{subchunk_coords}
\title{Load and store SubchunkBlocks data}
\usage{
get_subchunk_blocks_data(
  x,
  z,
  dimension,
  subchunk,
  db,
  names_only = FALSE,
  extra_block = FALSE
)

get_subchunk_blocks_value(
  x,
  z,
  dimension,
  subchunk,
  db,
  names_only = FALSE,
  extra_block = FALSE
)

put_subchunk_blocks_data(values, x, z, dimension, subchunk, db, version = 9L)

put_subchunk_blocks_value(value, x, z, dimension, subchunk, db, version = 9L)

read_subchunk_blocks_value(
  rawdata,
  missing_offset = NA,
  names_only = FALSE,
  extra_block = FALSE
)

write_subchunk_blocks_value(object, version = 9L, missing_offset = NA_integer_)

subchunk_origins(keys)

subchunk_coords(ind, origins = subchunk_origins(names(ind)))
}
\arguments{
\item{x, z, dimension}{Chunk coordinates to extract data from.
\code{x} can also be a character vector of db keys.}

\item{subchunk}{Subchunk indexes to extract data from.}

\item{db}{A bedrockdb object.}

\item{names_only}{A logical scalar. Return only the names of the blocks.}

\item{extra_block}{A logical scalar. Append the extra block layer to the
output (separated by ";"). This is mostly useful if you have waterlogged
blocks. If the extra block is air, it will not be appended.}

\item{values}{A list of 16x16x16 character() arrays. If \code{x} is missing, the names of \code{values} will be taken as the keys.
ignoring block states.}

\item{version}{Which format of subchunk data to use}

\item{value}{A 16x16x16 character array.}

\item{rawdata}{a raw vector holding binary SubchunkBlock data}

\item{missing_offset}{subchunk offset to use if one is not found in \code{rawdata}}

\item{object}{A 16x16x16 character array.}

\item{keys}{A character vector of database keys.}

\item{ind}{Numeric vector or a named list of numeric vectors containing
indexes for blocks in a subchunk.}

\item{origins}{A matrix of subchunk origins.}
}
\value{
\code{get_subchunk_blocks_value()} and \code{read_subchunk_blocks_value()}
return a 16x16x16 character array. The axes represent the \code{x}, \code{y}, and \code{z}
dimensions in that order.
\code{get_subchunk_blocks_data()}
return a list of the of the values returned by \code{read_subchunk_blocks_value()}.
\code{read_subchunk_blocks_value()} returns a 16x16x16 character array.
The axes represent the \code{x}, \code{y}, and \code{z} dimensions in that order.

If a subchunk contains only air it will not be stored in the database, and
missing subchunks are considered air.

\code{subchunk_coords()} returns a 3-column matrix of block coordinates.
}
\description{
SubchunkBlocks data (tag 47) holds information about the blocks in a
subchunks. Each chunk is divided into multiple 16x16x16 subchunks, and each
subchunk is stored separately and indicated by the use of the subtag.
Blocks are stored in a palette-based format. Subchunks can have two layers
of blocks, and the extra layer is most-often used to store water for
water-logged blocks.

\code{subchunk_origins()} returns a matrix containing the block coordinate of the
lower NW corner of subchunk keys

\code{subchunk_coords()} determines the block coordinates of blocks based on their
array indexes and their subchunk origins.
}
\details{
These functions return block data as strings containing the
block name and block states. The strings' format is
\code{blockname@state1=value1@state2=value2} etc.
Blocks may have 0 or more states.

\code{get_subchunk_blocks_data()} and \code{get_subchunk_blocks_value()} load SubchunkBlocks data from \code{db}.
\code{get_subchunk_blocks_value()} only supports loading a single value.

\code{put_subchunk_blocks_data()}, \code{put_subchunk_blocks_values()}, and
\code{put_subchunk_blocks_value()} store SubchunkBlocks data into \code{db}.

\code{read_subchunk_blocks_value()} decodes binary SubchunkBlock data.
}
